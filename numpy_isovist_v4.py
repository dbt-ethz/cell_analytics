# -*- coding: utf-8 -*-
"""numpy_isovist_v4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OqIoL5SQJV-gcvPI-tw9yD1gAzh9NjvQ
"""

import numpy as np
import matplotlib.pyplot as plt

class Isovist:
  """
  A class to compute isovist using numpy
  (https://en.wikipedia.org/wiki/Isovist)
  (https://numpy.org/)
  -
  / Attributes 
  ------------
  obstacle_map : 2D numpy array 
      -1 for collision and 0 for ground
  -
  / Methods
  ------------
  isovist_from_point(startIndex, youAreHere=False, format=0)
      Create a 1D or 2D isovist numpy array from a starting point
  -
  isovist_map(format=0)
      Create a 1D or 2D isovist numpy array with visibility percentage of each cell
  """
  
  
  def __init__(self, obstacle_map):
    self.obstacle_map = obstacle_map
    self.visible_cells = np.argwhere(obstacle_map==0)
  
  
  def isovist_from_point(self, startIndex, youAreHere=False, format=0):
      """
      Create a 2D or 1D isovist numpy array from a starting point
      -
      / Input
      startIndex = pov point (x,y)
      obstacle_map = 2D numpy array with -1 for collision and 0 for ground
      youAreHere = Boolean to highlight pov with value -2
      format = 0 for 1D numpy array ouput / = 1 for 2D numpy array output
      -
      / Output
      newMap = Isovist Map with -1 collision, 0 non-visible ground, 1 visible ground
      """
      isovist_area = np.copy(self.obstacle_map)
      
      # Edges cells
      coords_arrs = np.mgrid[0:self.obstacle_map.shape[0], 0:self.obstacle_map.shape[1]]
      edges = [np.concatenate([arr[0,:-1],
                                arr[:-1,-1],
                                arr[-1,::-1],
                                arr[-2:0:-1,0]]) for arr in coords_arrs]
      
      # Shoot rays
      for xEdg, yEdg in zip(edges[0], edges[1]):
          self.visibility_ray(startIndex, (yEdg, xEdg), isovist_area)
      
      # Highlight pov
      if youAreHere:
          isovist_area[startIndex[1], startIndex[0]] = -2
  
      # Export options
      if format == 0:
          return isovist_area.flatten()
      elif format == 1:
          return isovist_area
  
  
  def isovist_map(self, format=0):
    """
    Create a 1D or 2D isovist numpy array with visibility percentage for each cell
    -
    / Input
    obstacle_map = 2D numpy array with -1 for collision and 0 for ground
    format = 0 for 1D numpy array ouput / = 1 for 2D numpy array output
    -
    / Output
    isovist_map = Isovist for each cell in a 1D or 2D numpy array 
    """
    
    isovist_map = np.copy(self.obstacle_map)
    
    # Edges cells
    coords_arrs = np.mgrid[0:self.obstacle_map.shape[0], 0:self.obstacle_map.shape[1]]
    edges = [np.concatenate([arr[0,:-1],
                             arr[:-1,-1],
                             arr[-1,::-1],
                             arr[-2:0:-1,0]]) for arr in coords_arrs]
    
    # Shoot rays and count enlightened cells
    povMap = np.zeros(self.obstacle_map.shape, dtype=np.int)
    for [startX, startY] in self.visible_cells:
        for xEdg, yEdg in zip(edges[0], edges[1]):
            self.visibility_ray((startY, startX), (yEdg, xEdg), povMap)  

        # Percentage of visibility per cell
        isovist_map[startX, startY] = (np.count_nonzero(povMap) / self.visible_cells.size) * 100
        povMap = np.zeros(self.obstacle_map.shape, dtype=np.int)

    # Export options
    if format == 0:
        return isovist_map.flatten()
    elif format == 1:
        return isovist_map
  

  def visibility_ray(self, startIndex, endIndex, visibility_map):
    """
    Bresenham's Line Algorithm using np array to detect collision
    -
    / Input
    startIndex = (x,y) corrdinates of ray's starting point
    endIndex = (x,y) coordinates of ray's ending point
    obstacle_map = 2D numpy array with -1 for collision and 0 for ground
    visibility_map = 2D numpy array to be updated
    -
    / Output
    visibility_map updated with the shooted ray
    """
    
    # Setup initial conditions
    x1, y1 = startIndex
    x2, y2 = endIndex
    dx = x2 - x1
    dy = y2 - y1
    
    # Determine how steep the line is
    is_steep = abs(dy) > abs(dx)
    
    # Rotate line
    if is_steep:
        x1, y1 = y1, x1
        x2, y2 = y2, x2
    
        # Recalculate differentials
        dx = abs(x2 - x1)
        dy = abs(y2 - y1)
        
        # Calculate error
        error = int(dx / 2.0)
        ystep = 1 if y1 < y2 else -1
        
        # Inverse orientation
        incr = 1 if x1 < x2 else -1
        
        # Iterate over bounding box generating points between start and end
        y = y1
        for x in range(x1, x2 + incr, incr):
            if not self.obstacle_map[x,y] < 0:
              visibility_map[x,y] = 1
              error -= abs(dy) 
              if error < 0:
                  y += ystep
                  error += dx
            else:
                break
    else:
        # Recalculate differentials
        dx = abs(x2 - x1)
        dy = abs(y2 - y1)
        
        # Calculate error
        error = int(dx / 2.0)
        ystep = 1 if y1 < y2 else -1
        
        # Inverse orientation
        incr = 1 if x1 < x2 else -1
        
        # Iterate over bounding box generating points between start and end
        y = y1
        for x in range(x1, x2 + incr, incr):
            if not self.obstacle_map[y,x] < 0:
              visibility_map[y,x] = 1
              error -= abs(dy) 
              if error < 0:
                  y += ystep
                  error += dx
            else:
                break

class Shortestpath:
  """
  Graph analytic's class to compute betweenness centrality using numpy
  (https://en.wikipedia.org/wiki/Betweenness_centrality)
  (https://numpy.org/)
  -
  / Attributes 
  ------------
  obstacle_map : 2D numpy array 
      -1 for collision and 0 for ground
  -
  / Methods
  ------------
  get_minimal_spanningtree(startIndex, youAreHere=False, format=0)
  -
  get_shortest_path(startIndex, endIndex, youAreHere=False, format=0)
  -
  get_centrality(format=0)
  -
  get_traffic(format=0)
  """
  
  
  def __init__(self, obstacle_map):
    self.obstacle_map = obstacle_map
    self.visible_cells = np.argwhere(obstacle_map==0)
    self.nbarr = self.get_1D_neighbors()
  

  ####
  
  def indexFromXY(self, x, y, nY):
    """
    Return 1D index from a 2D array
    -
    / Input
    x = 
    y = 
    nY = 
    """
    return x*nY + y
  
  ####
  
  def get_1D_neighbors(self):
    """
    Return 1D numpy array with 8 neighbor cell's keys
    -
    / Input
    obstacle_map = 2D numpy array with -1 for collision and 0 for ground
    -
    / Output
    nb = 1D numpy array (with (map.size,8) as shape) with 8 neighbor cell's 1D keys
    """
    adjacents = [(-1,-1), (-1,0), (-1,1), (0,1), (1,1), (1,0), (1,-1), (0,-1)]
    
    nb = np.full((self.obstacle_map.size,8), -1, dtype=np.int)
    
    for [x,y] in self.visible_cells:
        index_1D = self.indexFromXY(x,y,self.obstacle_map.shape[1])
        for i, (xpos,ypos) in enumerate(adjacents):
            if 0 <= x+xpos < self.obstacle_map.shape[0] and 0 <= y+ypos < self.obstacle_map.shape[1]:
                if not self.obstacle_map[x+xpos, y+ypos] < 0:
                    nb[index_1D, i] = self.indexFromXY(xpos+x, ypos+y, self.obstacle_map.shape[1])
    return nb
  
  #####
  
  def get_minimal_spanningtree(self, startIndex, youAreHere=False, format=0):
    """
    Dijkstra's algorithm to compute distance from one cell to all others
    and minimal spanning tree
    -
    / Input
    startIndex = 1D key of start cell (x*nY + y)
    obstacle_map = 2D numpy array with -1 for collision and 0 for ground
    nbarr = 1D numpy array with 8 neighbor cell's indexes for ground / -1 for collision
    youAreHere = Boolean to highlight pov by newMap[start] = -2
    format = 0 for 1D numpy array / = 1 for 2D numpy array
    -
    / Output
    distArr = 1D or 2D numpy array with distances from start cell
    predArr = 1D or 2D numpy array with closest coordinates from start cell (minimal spanning tree)
    """
    
    # Vectorized shortest distance
    distArr = np.where(self.obstacle_map.flatten() < 0, -1, np.full(self.obstacle_map.size, np.inf))
    distArr[startIndex] = 0
    indexes = np.full((self.obstacle_map.size), -1, dtype=np.int)
    predArr = np.full((self.obstacle_map.size), -1, dtype=np.int)
    
    check = np.where(distArr==0)[0]
    nNew = check.size
    indexes[0:nNew] = check
    predArr[0:nNew] = check
    endI = nNew
    weights = [1.4, 1, 1.4, 1, 1.4, 1, 1.4, 1]
    
    while nNew > 0:
        nNew = 0
        for i in range(endI):
            cellIndex = indexes[i]
            if not cellIndex < 0: 
                nbrs = self.nbarr[cellIndex]
                for j, nbr in enumerate(nbrs):
                    if not nbr < 0:
                        cost = distArr[cellIndex] +  weights[j] 
                        if distArr[nbr] > cost:
                            distArr[nbr] = cost
                            indexes[endI+nNew] = nbr
                            predArr[nbr] = cellIndex
                            nNew += 1
        
        indexes[0 : nNew] = indexes[endI : endI + nNew]
        endI = nNew
    
    distArr = np.where(distArr == np.inf, -1, distArr)
    
    # Highlight pov
    if youAreHere:
        distArr[startIndex] = np.inf
    
    if format == 0:
        return distArr, predArr
    
    elif format == 1:
        # Reshape (1D -> 2D) and Rewrite infinities (inf -> -1)
        distArr = np.reshape(distArr, self.obstacle_map.shape)
        
        # Reshape (1D -> 2D) closest neighbor key from start cell
        p = np.full((self.obstacle_map.size,2), -1, dtype=np.int)
        for i, _ in enumerate(predArr):
            if not _ < 0:
                p[i] = [int(_/self.obstacle_map.shape[1]), int(_%self.obstacle_map.shape[1])]
        p = np.reshape(p,(*self.obstacle_map.shape, 2))
        
        return distArr, p
  
  #####
  
  def get_shortest_path(self, startIndex, endIndex, youAreHere=False, format=0):
    """

    """
    shortestPath_map = np.copy(self.obstacle_map.flatten())
    
    pred = self.get_minimal_spanningtree(startIndex)[1]
    self.get_path(startIndex, endIndex, pred, shortestPath_map)
    
    # Export options
    if format == 0:
        return shortestPath_map
    elif format == 1:
        return np.reshape(shortestPath_map, self.obstacle_map.shape)
  
  #####
  
  def get_path(self, startIndex, endIndex, predArr, visible_map):
    """
    Find path between two cells based on minimim spanning tree
    -
    / Input
    startIndex = 1D key of start cell
    endIndex = 1D key of end cell
    predArr = 1D numpy array with closest coordinates from startIndexes
    visible_map = 1D numpy array with -1 for collision and 0 for ground
    -
    / Output
    Update visible_map with 1 for path cells, 0 for ground and -1 for collision
    """
    visible_map[endIndex] += 1
    v = predArr[endIndex]
    
    while v != startIndex:
        visible_map[v] += 1
        v = predArr[v]
    visible_map[startIndex] += 1
  
  #####
  
  def get_centrality(self, format=0):
    """
    Return centrality map
    -
    / Input
    obstacle_map = 2D numpy array with -1 for collision and 0 for ground
    format = 0 for 1D numpy array / = 1 for 2D numpy array
    -
    / Output
    centralityMap = 1D or 2D numpy array with centrality percentage for each cell
    """
    centralityMap = np.zeros(self.obstacle_map.size, dtype=np.int)
    
    # Ground cells
    vCells = np.argwhere(self.obstacle_map.flatten() == 0).flatten()
    
    for k in vCells:
      dist = self.get_minimal_spanningtree(k)[0]
      centralityMap[k] = dist[dist > 0].sum() / np.sum(dist > 0)
    
    if format == 0:
      return centralityMap
    elif format == 1:
      return np.reshape(centralityMap, self.obstacle_map.shape)
  
  #####

  def get_cell_traffic(self, startIndex, traffic_map):
    """
    Return traffic of a specific cell
    -
    / Input
    startIndex = 1D 
    traffic_map = 
    -
    / Output
    traffic_map updated from startIndex cell traffic
    """    
    pred = self.get_minimal_spanningtree(startIndex)[1]
    pr = np.concatenate(np.argwhere(pred > 0))
    
    for p in pr:
        # self.get_shortest_path(startIndex, p, pred, traffic_map)
        self.get_path(startIndex, p, pred, traffic_map)
  
  #####
  
  def get_traffic(self, format=0):
    """

    -
    / Input
    obstacle_map = 2D numpy array with -1 for collision and 0 for ground
    nbarr = 
    format = 0 for 1D numpy array / = 1 for 2D numpy array
    -
    / Output
    trafficMap = 2D numpy array with road traffic
    """
    
    trafficMap = np.zeros(self.obstacle_map.size,dtype=np.int)

    # Ground cells
    vCells = np.argwhere(self.obstacle_map.flatten()==0).flatten()
    
    # Update traffic map
    for k in vCells:
        self.get_cell_traffic(k, trafficMap)
    
    if format == 0:
      return trafficMap
    elif format == 1:
      return np.reshape(trafficMap, self.obstacle_map.shape)

def displayArray(data, height, col='binary', edgecol='w'):

    """
    Display a 2D numpy array using matplotlib
    -
    / Input
    data = 2D numpy array
    height = Height of the plot - Proportional length 
    col = Matplotlib color map for voxels - https://matplotlib.org/stable/gallery/color/colormap_reference.html
    edgecol = Matplotlib color palette for edges - https://matplotlib.org/stable/gallery/color/named_colors.html
    -
    / Output
    Plot a 2D numpy array using matplotlib
    """
    plt.figure(figsize=(height * (data.shape[1] / data.shape[0]), height))
    plt.pcolor(data,cmap=col,edgecolors=edgecol, linewidths=height * 0.06)
    plt.tight_layout()
    plt.show()

# Random map made of 0 for ground and -1 for collision
width = 80
height = 60

matrix = np.zeros((6),dtype=np.int)
matrix[2] = -1
map1 = np.random.choice(matrix, size=(height, width))
displayArray(map1, 8, col='binary')

IsoMap1 = Isovist(map1)
startPt = (20,10)
IsoPt = IsoMap1.isovist_from_point(startPt, youAreHere=True, format=1)
displayArray(IsoPt, 8, col='hot', edgecol='gold')

VisibilityMap1 = IsoMap1.isovist_map(format=1)
displayArray(VisibilityMap1, 8, col='hot', edgecol='gold')

spMap1 = Shortestpath(map1)
startPt1D = startPt[1]*map1.shape[1] + startPt[0]
print(map1.shape, startPt1D)

dist1, pred1 = spMap1.get_minimal_spanningtree(startPt1D, youAreHere=True, format=1)
displayArray(dist1, 8, col='hot', edgecol='gold')
# print(pred1)

endPt = (78,58)
endPt1D = endPt[1]*map1.shape[1] + endPt[0]
shortestPath = spMap1.get_shortest_path(startPt1D, endPt1D, format=1)
displayArray(shortestPath, 8, col='hot', edgecol='gold')

cmap1 = spMap1.get_centrality(format=1)

displayArray(cmap1, 8, col='hot', edgecol='gold')

tmap1 = spMap1.get_traffic(format=1)

displayArray(tmap1, 8, col='hot', edgecol='gold')

